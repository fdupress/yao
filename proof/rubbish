lemma GameReal_GameHybrid0 (A <: GSch.EncSecurity.Adv_IND_t{Rand,R,GameReal,GameHybrid}):
      islossless A.gen_query =>
      islossless A.get_challenge =>
      l = 0 =>  
    equiv [GameReal(Rand, A).garble ~ GameHybrid(Rand, A).garble : ={glob A, glob Rand, glob R} ==> ={res}].
    proof.
      move => Agen_query_ll Aget_challenge_ll eql_0.
      proc => //.
      seq 3 3 : (={glob A, glob Rand, glob R, real, query} /\ GameReal.a{1} = GameHybrid.a{2} /\ GameReal.b{1} = GameHybrid.b{2} /\ GameReal.ff{1} = GameHybrid.ff{2} /\ GameReal.pp{1} = GameHybrid.pp{2} /\ GameReal.yy{1} = GameHybrid.yy{2}).
      inline*. call (_ : true) => //.
      auto. 
      if.
      progress.
      seq 7 7 : (={glob A, glob Rand, glob R, real, query, p, r, topo} /\ GameReal.a{1} = GameHybrid.a{2} /\ GameReal.b{1} = GameHybrid.b{2} /\ GameReal.ff{1} = GameHybrid.ff{2} /\ GameReal.pp{1} = GameHybrid.pp{2} /\ GameReal.yy{1} = GameHybrid.yy{2} /\ GSch.EncSecurity.queryValid_IND query{1} /\ GSch.EncSecurity.queryValid_IND query{2} /\ p{1} = (if real{1} then snd query{1} else fst query{1}) /\ p{2} = (if real{2} then snd query{2} else fst query{2}) /\ p{1} = (GameReal.fn{1}, GameReal.i{1}) /\ p{2} = (GameHybrid.fn{2}, GameHybrid.i{2}) /\ GameReal.fn{1} = GameHybrid.fn{2} /\ GameReal.fn{1} = (topo{1}, GameReal.gg{1}) /\ GameHybrid.fn{2} = (topo{2}, GameHybrid.gg{2}) /\ GameReal.i{1} = GameHybrid.i{2} /\ GameReal.v{1} = GameHybrid.v{2} /\ GameReal.v{1} = (GSch.Sch.Scheme.eval GameReal.fn{1} GameReal.i{1}) /\ GameHybrid.v{2} = (GSch.Sch.Scheme.eval GameHybrid.fn{2} GameHybrid.i{2}) /\ GameReal.gg{1} = GameHybrid.gg{2} /\ topo{1} = (GameReal.n{1}, GameReal.m{1}, GameReal.q{1}, GameReal.aa'{1}, GameReal.bb'{1}) /\ topo{2} = (GameHybrid.n{2}, GameHybrid.m{2}, GameHybrid.q{2}, GameHybrid.aa'{2}, GameHybrid.bb'{2}) /\ GameReal.n{1} = GameHybrid.n{2} /\ GameReal.m{1} = GameHybrid.m{2} /\ GameReal.q{1} = GameHybrid.q{2} /\ GameReal.aa'{1} = GameHybrid.aa'{2} /\ GameReal.bb'{1} = GameHybrid.bb'{2} /\ GameReal.g{1} = GameReal.n{1} /\ GameHybrid.g{2} = GameHybrid.n{2} /\ GameReal.g{1} = GameHybrid.g{2}). 
      auto. call (_ : ={l, glob Rand, glob R} ==> ={glob Rand, glob R, res}) => //. sim. auto.
      progress. smt. smt. smt. smt. smt. smt. 
      wp. call (_ : true) => //.
      wp. 
      while (={glob A, glob Rand, glob R, real, query, p, r, topo} /\ GSch.EncSecurity.queryValid_IND query{1} /\ GSch.EncSecurity.queryValid_IND query{2} /\ p{1} = (if real{1} then snd query{1} else fst query{1}) /\ p{2} = (if real{2} then snd query{2} else fst query{2}) /\ p{1} = (GameReal.fn{1}, GameReal.i{1}) /\ p{2} = (GameHybrid.fn{2}, GameHybrid.i{2}) /\ GameReal.fn{1} = GameHybrid.fn{2} /\ GameReal.fn{1} = (topo{1}, GameReal.gg{1}) /\ GameHybrid.fn{2} = (topo{2}, GameHybrid.gg{2}) /\ GameReal.i{1} = GameHybrid.i{2} /\ GameReal.v{1} = GameHybrid.v{2} /\ GameReal.v{1} = (GSch.Sch.Scheme.eval GameReal.fn{1} GameReal.i{1}) /\ GameHybrid.v{2} = (GSch.Sch.Scheme.eval GameHybrid.fn{2} GameHybrid.i{2}) /\ GameReal.gg{1} = GameHybrid.gg{2} /\ topo{1} = (GameReal.n{1}, GameReal.m{1}, GameReal.q{1}, GameReal.aa'{1}, GameReal.bb'{1}) /\ topo{2} = (GameHybrid.n{2}, GameHybrid.m{2}, GameHybrid.q{2}, GameHybrid.aa'{2}, GameHybrid.bb'{2}) /\ GameReal.n{1} = GameHybrid.n{2} /\ GameReal.m{1} = GameHybrid.m{2} /\ GameReal.q{1} = GameHybrid.q{2} /\ GameReal.aa'{1} = GameHybrid.aa'{2} /\ GameReal.bb'{1} = GameHybrid.bb'{2} /\ GameReal.g{1} = GameHybrid.g{2} /\ GameReal.n{1} <= GameReal.g{1} <= GameReal.n{1} + GameReal.q{1} /\ GameHybrid.n{2} <= GameHybrid.g{2} <= GameHybrid.n{2} + GameHybrid.q{2} /\ GameReal.a{1} = GameHybrid.a{2} /\ GameReal.b{1} = GameHybrid.b{2} /\ GameReal.ff{1} = GameHybrid.ff{2} /\ GameReal.pp{1} = GameHybrid.pp{2} /\ GameReal.yy{1} = GameHybrid.yy{2}).
      inline *. auto. progress. smt. smt. smt. smt. 
rewrite eql_0. simplify.
     cut ? : 0 <= GameHybrid.aa'{2}.[GameHybrid.g{2}]. smt.
cut ? : GameHybrid.aa'{2}.[GameHybrid.g{2}] <= l - 1 <=> false. smt. move : H15. rewrite H19. progress. 
rewrite eql_0. simplify.
     cut ? : 0 <= GameHybrid.aa'{2}.[GameHybrid.g{2}]. smt.
cut ? : GameHybrid.aa'{2}.[GameHybrid.g{2}] <= l - 1 <=> false. smt. move : H15. rewrite H19. progress. 
smt. smt. smt. smt. 

cut ? : 0 <= GameHybrid.aa'{2}.[GameHybrid.g{2}]. cut ->: GameHybrid.aa'{2} = query{2}.`2.`1.`1.`4. smt. smt. 
cut -> : GameHybrid.aa'{2}.[GameHybrid.g{2}] <= l - 1 <=> false. smt. 
cut ? : 0 <= GameHybrid.bb'{2}.[GameHybrid.g{2}]. cut ->: GameHybrid.bb'{2} = query{2}.`2.`1.`1.`5. smt. smt. 
cut -> : GameHybrid.bb'{2}.[GameHybrid.g{2}] <= l - 1 <=> false. smt. 

     simplify. trivial. 
cut ? : 0 <= GameHybrid.aa'{2}.[GameHybrid.g{2}]. cut ->: GameHybrid.aa'{2} = query{2}.`2.`1.`1.`4. smt. smt. 
cut -> : GameHybrid.aa'{2}.[GameHybrid.g{2}] <= l - 1 <=> false. smt. simplify. trivial.
auto. progress. cut ->: GameHybrid.q{2} = query{2}.`2.`1.`1.`3. smt. smt. cut ->: GameHybrid.q{2} = query{2}.`2.`1.`1.`3. smt. smt.
auto.
qed.

    lemma GameFake_GameHybrid_bound (A <: GSch.EncSecurity.Adv_IND_t{Rand,R,GameFake,GameHybrid}):
      islossless A.gen_query =>
      islossless A.get_challenge =>
      l = bound =>  
    equiv [GameFake(Rand, A).garble ~ GameHybrid(Rand, A).garble : ={glob A, glob Rand, glob R} ==> ={res}].
    proof.
      move => Agen_query_ll Aget_challenge_ll hl.
      proc => //.
      seq 3 3 : (={glob A, glob Rand, glob R, real, query} /\ GameFake.a{1} = GameHybrid.a{2} /\ GameFake.b{1} = GameHybrid.b{2} /\ GameFake.ff{1} = GameHybrid.ff{2} /\ GameFake.pp{1} = GameHybrid.pp{2} /\ GameFake.yy{1} = GameHybrid.yy{2}).
      inline*. call (_ : true) => //.
      auto. 
      if.
      progress.
      seq 7 7 : (={glob A, glob Rand, glob R, real, query, p, r, topo} /\ GameFake.a{1} = GameHybrid.a{2} /\ GameFake.b{1} = GameHybrid.b{2} /\ GameFake.ff{1} = GameHybrid.ff{2} /\ GameFake.pp{1} = GameHybrid.pp{2} /\ GameFake.yy{1} = GameHybrid.yy{2} /\ GSch.EncSecurity.queryValid_IND query{1} /\ GSch.EncSecurity.queryValid_IND query{2} /\ p{1} = (if real{1} then snd query{1} else fst query{1}) /\ p{2} = (if real{2} then snd query{2} else fst query{2}) /\ p{1} = (GameFake.fn{1}, GameFake.i{1}) /\ p{2} = (GameHybrid.fn{2}, GameHybrid.i{2}) /\ GameFake.fn{1} = GameHybrid.fn{2} /\ GameFake.fn{1} = (topo{1}, GameFake.gg{1}) /\ GameHybrid.fn{2} = (topo{2}, GameHybrid.gg{2}) /\ GameFake.i{1} = GameHybrid.i{2} /\ GameFake.v{1} = GameHybrid.v{2} /\ GameFake.v{1} = (GSch.Sch.Scheme.eval GameFake.fn{1} GameFake.i{1}) /\ GameHybrid.v{2} = (GSch.Sch.Scheme.eval GameHybrid.fn{2} GameHybrid.i{2}) /\ GameFake.gg{1} = GameHybrid.gg{2} /\ topo{1} = (GameFake.n{1}, GameFake.m{1}, GameFake.q{1}, GameFake.aa'{1}, GameFake.bb'{1}) /\ topo{2} = (GameHybrid.n{2}, GameHybrid.m{2}, GameHybrid.q{2}, GameHybrid.aa'{2}, GameHybrid.bb'{2}) /\ GameFake.n{1} = GameHybrid.n{2} /\ GameFake.m{1} = GameHybrid.m{2} /\ GameFake.q{1} = GameHybrid.q{2} /\ GameFake.aa'{1} = GameHybrid.aa'{2} /\ GameFake.bb'{1} = GameHybrid.bb'{2} /\ GameFake.g{1} = GameFake.n{1} /\ GameHybrid.g{2} = GameHybrid.n{2} /\ GameFake.g{1} = GameHybrid.g{2} /\ l = GameHybrid.n{2} + GameHybrid.q{2} - GameHybrid.m{2}). 
      auto. call (_ : ={l, glob Rand, glob R} /\ GameFake.a{1} = GameHybrid.a{2} /\ GameFake.b{1} = GameHybrid.b{2} /\ GameFake.ff{1} = GameHybrid.ff{2} /\ GameFake.pp{1} = GameHybrid.pp{2} /\ GameFake.yy{1} = GameHybrid.yy{2} ==> ={glob Rand, glob R, res} /\ GameFake.a{1} = GameHybrid.a{2} /\ GameFake.b{1} = GameHybrid.b{2} /\ GameFake.ff{1} = GameHybrid.ff{2} /\ GameFake.pp{1} = GameHybrid.pp{2} /\ GameFake.yy{1} = GameHybrid.yy{2}) => //. sim. auto.
      progress. smt. smt. smt. smt. smt. smt. move : H. rewrite /queryValid_IND. rewrite /valid_plain. rewrite /validInputs. rewrite valid_wireinput. rewrite /valid_circuitP. simplify fst snd. case (real{2}). smt. smt. 
      wp. call (_ : true) => //.
      wp.
      while (={glob A, glob Rand, glob R, real, query, p, r, topo} /\ GSch.EncSecurity.queryValid_IND query{1} /\ GSch.EncSecurity.queryValid_IND query{2} /\ p{1} = (if real{1} then snd query{1} else fst query{1}) /\ p{2} = (if real{2} then snd query{2} else fst query{2}) /\ p{1} = (GameFake.fn{1}, GameFake.i{1}) /\ p{2} = (GameHybrid.fn{2}, GameHybrid.i{2}) /\ GameFake.fn{1} = GameHybrid.fn{2} /\ GameFake.fn{1} = (topo{1}, GameFake.gg{1}) /\ GameHybrid.fn{2} = (topo{2}, GameHybrid.gg{2}) /\ GameFake.i{1} = GameHybrid.i{2} /\ GameFake.v{1} = GameHybrid.v{2} /\ GameFake.v{1} = (GSch.Sch.Scheme.eval GameFake.fn{1} GameFake.i{1}) /\ GameHybrid.v{2} = (GSch.Sch.Scheme.eval GameHybrid.fn{2} GameHybrid.i{2}) /\ GameFake.gg{1} = GameHybrid.gg{2} /\ topo{1} = (GameFake.n{1}, GameFake.m{1}, GameFake.q{1}, GameFake.aa'{1}, GameFake.bb'{1}) /\ topo{2} = (GameHybrid.n{2}, GameHybrid.m{2}, GameHybrid.q{2}, GameHybrid.aa'{2}, GameHybrid.bb'{2}) /\ GameFake.n{1} = GameHybrid.n{2} /\ GameFake.m{1} = GameHybrid.m{2} /\ GameFake.q{1} = GameHybrid.q{2} /\ GameFake.aa'{1} = GameHybrid.aa'{2} /\ GameFake.bb'{1} = GameHybrid.bb'{2} /\ GameFake.g{1} = GameHybrid.g{2} /\ GameFake.n{1} <= GameFake.g{1} <= GameFake.n{1} + GameFake.q{1} /\ GameHybrid.n{2} <= GameHybrid.g{2} <= GameHybrid.n{2} + GameHybrid.q{2} /\ GameFake.a{1} = GameHybrid.a{2} /\ GameFake.b{1} = GameHybrid.b{2} /\ GameFake.ff{1} = GameHybrid.ff{2} /\ GameFake.pp{1} = GameHybrid.pp{2} /\ GameFake.yy{1} = GameHybrid.yy{2} /\ l = GameHybrid.n{2} + GameHybrid.q{2} - GameHybrid.m{2}). 
     inline *. auto. progress. smt. smt. smt. smt. 
cut : false. smt. progress. cut : false. smt. progress. smt. smt. smt. smt. 
rewrite ?H7. cut ->: GameHybrid.aa'{2}.[GameHybrid.g{2}] <= GameHybrid.n{2} + GameHybrid.q{2} - GameHybrid.m{2} - 1 <=> true. smt. cut ->: GameHybrid.bb'{2}.[GameHybrid.g{2}] <= GameHybrid.n{2} + GameHybrid.q{2} - GameHybrid.m{2} - 1 <=> true. smt. simplify. trivial. rewrite ?H7. cut ->: GameHybrid.aa'{2}.[GameHybrid.g{2}] <= GameHybrid.n{2} + GameHybrid.q{2} - GameHybrid.m{2} - 1 <=> true. smt. simplify. trivial. 
skip. progress. cut ->: GameHybrid.q{2} = query{2}.`2.`1.`1.`3. smt. smt. cut ->: GameHybrid.q{2} = query{2}.`2.`1.`1.`3. smt. smt.
auto.
qed.
