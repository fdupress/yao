(** Security definitions for an encryption scheme *)

require import Pair.
require import Bool.
require import Real.
require import Distr.
require import DBool.

require import Enc.

(**
  The security of an encryption scheme can be defined in two settings:
    - IND model - where an adversary is asked to, given a ciphertext, guess
    which of two plaintexts gave origin to it.
    - SIM model - where an adversary is asked to distinguish if a ciphertext
    was generated by an encryption scheme or by some simulation of the scheme.
*)
theory EncSecurity.
  clone import Encryption.

  (** Random generator *)
  module type Rand_t = {
     proc gen(l:randgenin): rand
  }.

  (** Definitions needed for IND model *)
  
  (** Type of the query of the adversary *)
  (** An adversary queries two plaintexts *)
  type query_IND = plain * plain.

  (** Validity of a query *)
  (**  
    A query is valid if the plaintexts are admissable to the scheme and
    if they leak the same information (for example, if the leakage is the
    size of the plaintext, then the sizes should be the same).
  *)
  op queryValid_IND(query : query_IND) =
     valid_plain (fst query) /\ 
     valid_plain (snd query) /\
     leak (fst query) = leak (snd query).

  (** Adversary attacking the IND security of the scheme *)
  (**
    An adversary attacking the IND security of the scheme
    is able to produce a query made of two plaintexts and then,
    receiving the ciphertext resulting of the encryption of 
    one of them, is able to distinguish from which plaintext it
    came from.
  *)
  module type Adv_IND_t = {
    proc gen_query(): query_IND
    proc get_challenge(cipher:cipher): bool
  }.

  (** Cryptographic game that defines the IND security *)
  (**
    This game will use the adversary defined above (that is able to distinguish
    the plaintext that gave origin to some ciphertext) to try to break the IND 
    security of the encryption scheme.

    The routine starts by using the adversary to produce to a query. After,
    it will use the "challenger" to cipher one of the messages. Finally, it will
    ask the adversary to guess from which plaintext the ciphertext comes from.
  *)
  module Game_IND(R:Rand_t, ADV:Adv_IND_t) = {
    proc main(): bool = {
      var query:query_IND;
      var p:plain;
      var c:cipher;
      var b,adv,ret:bool;
      var r:rand;

      b = $DBool.dbool;
      query = ADV.gen_query();
      if (queryValid_IND query)
      {
        p = if b then snd query else fst query;
        r = R.gen(randfeed p);
        c = enc p r;
        adv = ADV.get_challenge(c);
        ret = (b = adv);
      }
      else
        ret = $DBool.dbool;
      return ret;
    }
  }.

  (***************************)
  (* Lossnessness properties *)
  (***************************)

  lemma Game_INDmain_lossless (R <: Rand_t) (A <: Adv_IND_t) :
    islossless R.gen =>
    islossless A.gen_query =>
    islossless A.get_challenge =>
    islossless Game_IND(R,A).main.
  proof.
    move => Rgen_ll Agen_query_ll Aget_challenge_ll.
    proc => //.
    seq 2 : true => //.
      call (_:true) => //.
      by rnd; skip; smt.
    if.
    (*queryValid_IND query*)
      do (wp;call (_:true) => //;wp).
      by skip; trivial.
    (*! queryValid_IND query*)
      by rnd; skip; smt.
  qed.

  (** Definitions needed for SIM model *)
  
  (** Type of the query of the adversary *)
  (** An adversary queries one plaintexts *)
  type query_SIM = plain.

  (** Validity of a query *)
  (**  
    A query is valid if the plaintext in it is valid
  *)
  op queryValid_SIM(query:query_SIM) =
     valid_plain query.

  (** Invertibility of leakage function *)
  (**
    The security is defined if the leakage is invertible, i.e.,
    if there is an efficient function that, given the leakage of
    a plaintext, returns a valid plaintext with the same leakage
    information.

    For example, if one considers the leakage of a plaintext to be
    its length, then pi_sampler should return another plaintext with
    the same length.
  *)
  pred pi_sampler_works (x:unit) =
    forall (plain : plain),
      valid_plain plain =>
      let leakage = leak plain in
      let pi = pi_sampler leakage in
        leak pi = leakage /\ valid_plain pi.

  (** Adversary attacking the SIM security of the scheme *)
  (**
    An adversary attacking the SIM security of the scheme
    is able to produce a query made of one plaintext and then,
    on input a ciphertext, is able to distinguish if it is
    the encryption of the queried plaintext under the encryption 
    scheme or if is the result of a simulated execution of the
    encryption scheme, with some plaintext generated from pi_sampler.
  *)
  module type Adv_SIM_t = {
    proc gen_query():query_SIM
    proc get_challenge(cipher:cipher): bool
  }.

  (** Simulator *)
  (**
    A simulator of the encryption scheme simulates the execution of the
    encryption scheme with respect to information leaked by the plaintext.
    The output of the simulator is a ciphertext that has similar behaviour
    when compared to a ciphertext generated by the encryption scheme itself.

    The intuition behind this definition is that the existance of a successful simulator
    establishes that the ciphertexts cannot possibly release more information
    about their original plaintexts in addition to the information received by
    the simulator (evaluation output and admissible leakage).
  *)
  module type Sim_SIM_t = {
    proc simm(leakage:leakage): cipher
  }.

  (** Cryptographic game that defines the SIM security *)
  (**
    This game will use the adversary defined above (that is able to distinguish
    between a real execution of the encryption scheme and a simulated one) to try to break
    the SIM security of the encryption scheme.

    The routine starts by using the adversary to produce a query. After it will use 
    the challenger to obtain either a truly encryption of the queried plaintext
    or a ciphertext that resulted from the simulation of the scheme. Finally, it will
    use the adversary to distinguish between both.
  *)
  module Game_SIM(R:Rand_t, SIM:Sim_SIM_t, ADV:Adv_SIM_t) = {
    proc game(b: bool): bool = {
      var query:query_SIM;
      var c:cipher;
      var b':bool;
      var r:rand;

      query = ADV.gen_query();

      if (!queryValid_SIM query)
         b' = $DBool.dbool;
      else
      {
        if (b)
        {
          r = R.gen(randfeed query); 
          c = enc query r; 
        }
        else c = SIM.simm(leak query);
        b' = ADV.get_challenge(c);
      }
      return (b = b');
    }
    proc main(): bool = {
      var real, adv: bool;
      real = $DBool.dbool;
      adv = game(real);
      return adv;
    }
  }.

  (** Explicit definition of the Simulator *)
  (**
    The simulator is a routine that, using the leakage produced
    by a plaintext, produces a plaintext and, using the random
    generator, encrypts the plaintext.
  *)
  module SIM(R:Rand_t): Sim_SIM_t = {
    proc simm(leakage:leakage): cipher = {
      var pi:plain;
      var c:cipher;
      var r:rand;

      pi = pi_sampler leakage;
      r = R.gen(randfeed pi);
      c = enc pi r;
      return c;
    }
  }.

  (***************************)
  (* Lossnessness properties *)
  (***************************)

  lemma Game_SIMgame_lossless (R <: Rand_t) (SIM <: Sim_SIM_t)
                              (ADV <: Adv_SIM_t) :
    islossless R.gen =>
    islossless ADV.gen_query =>
    islossless ADV.get_challenge =>
    islossless SIM.simm =>
    islossless Game_SIM(R,SIM,ADV).game.
  proof.
    move => Rgen_ll ADVgen_query_ll ADVget_challenge_ll SIMsimm_ll.
    proc => //.
    seq 1 : true => //; first by call(_:true) => //.
    if.
    (*! queryValid_SIM query*)
      by rnd; skip; smt.
    (*queryValid_SIM query*)
      if.
      (*b*)
        do (call (_:true) => //;wp).
      (*!b*)
        do (call (_:true) => //).
  qed.

  lemma Game_SIMmain_lossless (R <: Rand_t) (SIM <: Sim_SIM_t)
                              (ADV <: Adv_SIM_t) :
    islossless R.gen =>
    islossless ADV.gen_query =>
    islossless ADV.get_challenge =>
    islossless SIM.simm =>
    islossless Game_SIM(R,SIM,ADV).main.
  proof.
    move => Rgen_ll ADVgen_query_ll ADVget_challenge_ll SIMsimm_ll.
    proc => //.
    seq 1 : true => //; first by rnd; skip; smt => //.
    call (_:true) => //.
    seq 1 : true => //; first by call(_:true) => //.
    if.
    (*! queryValid_SIM query*)
      by rnd; skip; smt.
    (*queryValid_SIM query*)
      if.
      (*b*)
        do (call (_:true) => //;wp).
      (*!b*)
        do (call (_:true) => //).
  qed.
                              
  lemma SIMsimm_lossless (R <: Rand_t) :
    islossless R.gen =>
    islossless SIM(R).simm.
  proof.
    move => Rgen_ll.
    proc => //.
    wp.
    call (_:true) => //.
    by wp; skip; trivial.
  qed.

  (** Building an IND adversary from a SIM adversary *)
  (**
    It is possible to build and IND adversray form a SIM adversary.
    
    The SIM adversary creates a query, composed by a single plaintext. After,
    it obtains the leakage of the generated plaintext and, using the invertible
    leakage function, produces a new plaintext, ending up with a new query made
    of two plaintexts (= IND query).

    Being the SIM adversary able to distinguish if a ciphertext is from a real 
    execution of the encryption scheme or from a simulated one, the IND adversary 
    could use the result of the query of the SIM adversary to distinguish between
    the result of its query and it would be able to know from which the plaintexts
    the ciphertext was from.
  *)
  module RedSI(A:Adv_SIM_t) = {
    proc gen_query():query_IND = {
      var plain0:plain;
      var plain1:plain;
      var leakage0:leakage;

      plain0 = A.gen_query();
      leakage0 = leak plain0;
      plain1 = pi_sampler leakage0;
      return (plain1,plain0);
    }

    proc get_challenge(cipher : cipher) : bool = {
      var answer:bool;

      answer = A.get_challenge(cipher);
      return answer;
    }
  }.

  (***************************)
  (* Lossnessness properties *)
  (***************************)

  lemma RedSIgenL (A <: Adv_SIM_t): islossless A.gen_query => islossless RedSI(A).gen_query.
  proof. by move=> AgenL; proc; wp; call AgenL. qed.

  lemma RedSIgetL (A <: Adv_SIM_t): islossless A.get_challenge => islossless RedSI(A).get_challenge.
  proof. by move=> AgetL; proc; wp; call AgetL. qed.

  (*******************************************)
  (* IND => SIM proof                        *)
  (*******************************************)

  (**
    IND security implies SIM security if and only if the leakage function
    if efficiently invertible.
  *)
  section.
 
    declare module R:Rand_t.

    declare module A:Adv_SIM_t {R}.
    axiom AgenL: islossless A.gen_query.
    axiom AgetL: islossless A.get_challenge.

    (** Equivalence between IND and SIM games if the leakage function
    if efficiently invertible *)
    local lemma indadv_equiv (A <: Adv_SIM_t{R}):
      pi_sampler_works () =>
      equiv [ Game_IND(R,RedSI(A)).main ~ Game_SIM(R,SIM(R),A).main:
            ={glob R,glob A} ==> ={res} ].
    proof.
      move=> pi_samplable; proc.
      inline RedSI(A).gen_query Game_SIM(R, SIM(R), A).game RedSI(A).get_challenge
             SIM(R).simm.
      seq 5 3: (={b, glob R, glob A} /\ plain0{1} = query{2} /\ 
               leakage0{1} = leak plain0{1} /\ plain1{1} = pi_sampler leakage0{1} /\ 
               query{1} = (plain1{1}, plain0{1})).
        wp; call (_: true).
        by auto.
      case (queryValid_SIM query{2}); last first.
      rcondf{1} 1; first by move => &m; skip; progress; smt.
      rcondt{2} 1; first by move => &m; skip; smt.
        by wp; rnd ((=)b{2}); skip; progress; smt.
      rcondt{1} 1; first by move => &m; skip; progress; smt.
      rcondf{2} 1; first by move => &m; skip; smt.
        case (b{1}).
        rcondt{2} 1=> //.
          wp; call (_: true).
          wp; call (_: true).
          by auto; progress; smt.
        rcondf{2} 1=> //.
          wp; call (_: true).
          wp; call (_: true).
          by auto; progress; smt.
    qed.

    (** The equivalence between the two games defines that the advantage
        of an adversary is the same in both *)
    lemma simadv_indadv &m:
      pi_sampler_works () =>
      Pr[Game_IND(R,RedSI(A)).main()@ &m:res] = Pr[Game_SIM(R,SIM(R),A).main()@ &m:res].
    proof. by move=> pi_samplable; byequiv (indadv_equiv A _). qed.

    (** IND security implies SIM security iff the leakage function is invertible *)
    lemma ind_implies_sim &m:
      pi_sampler_works () =>
      `|2%r * Pr[Game_SIM(R,SIM(R),A).main()@ &m:res] - 1%r| <=
      `|2%r * Pr[Game_IND(R,RedSI(A)).main()@ &m:res] - 1%r|.
    proof. by move=> pi_samplable; rewrite -(simadv_indadv &m). qed.
  end section.

  (*********************************)
  (* GENERIC ADVANTAGE DEFINITIONS *)
  (*********************************)

  (**
     The advantage of an adversary against an encryption with respect
     to the games above is |2*Pr[adv = real] - 1|. The encryption scheme
     is secure in the presence of SIM adversaries if the advantage is
     negligeble.
      
     The probability Pr[adv = real] can be expandaded as 1/2 * (Pr[adv = real | real = true]
     + Pr[adv = real | real = false]).

     This advantage can be defined in the form of conditional probabilities as
     Pr[adv = real | real = true] - Pr[adv != real | real = false].
  *)
  
  (** Conditional probability expansion *)
  lemma SGame_xpn &m (A <: Adv_SIM_t {Game_SIM}) (S <: Sim_SIM_t {A}) (R <: Rand_t{A,S}):
    islossless A.gen_query =>
    islossless A.get_challenge =>
    islossless R.gen =>
    islossless S.simm =>
    Pr[Game_SIM(R,S,A).main()  @ &m: res]
    = 1%r/2%r * (Pr[Game_SIM(R,S,A).game(true)  @ &m: res]
      + Pr[Game_SIM(R,S,A).game(false)  @ &m: res]).
  proof.
    move => Agen_query_ll Aget_challenge_ll Rgen_ll Ssimm_ll.
    pose p1 := Pr[Game_SIM(R, S, A).game(true) @ &m : res].
    pose p2 := Pr[Game_SIM(R, S, A).game(false) @ &m : res].
    byphoare (_: (glob A) = (glob A){m} /\ (glob S) = (glob S){m} /\ (glob R) = (glob R){m} ==> _) => //.
    proc => //.
    seq 1: real (1%r/2%r) p1 (1%r/2%r) p2 ((glob A) = (glob A){m} /\ (glob S) = (glob S){m} /\ (glob R) = (glob R){m}); trivial.
      by auto.
      by rnd; skip; smt.
      call (_: ((glob A) = (glob A){m} /\ (glob S) = (glob S){m} /\ (glob R) = (glob R){m}) /\ b ==> res)=> //.
        rewrite /p1.
        bypr=> &m' [eqA] b'.
      byequiv (_: ={glob A, glob S, glob R, b} /\ b{1} ==> ={res})=> //.
        by sim.
        by rewrite b' eqA.
      by rnd; skip; smt.
      call (_: ((glob A) = (glob A){m} /\ (glob S) = (glob S){m} /\ (glob R) = (glob R){m}) /\ !b ==> res)=> //.
        rewrite /p2.
        bypr=> &m' [eqA] b'.
        byequiv (_: ={glob A, glob S, glob R, b} /\ !b{1} ==> ={res})=> //.
        by sim.
        by rewrite -neqF; rewrite b'; rewrite eqA.
    by smt.
  qed.

  (** Advantage definition *)
  lemma SGame_adv &m (A <: Adv_SIM_t {Game_SIM}) (S <: Sim_SIM_t {A}) (R <: Rand_t{A,S}):
    islossless A.gen_query =>
    islossless A.get_challenge =>
    islossless R.gen =>
    islossless S.simm =>
    2%r * Pr[Game_SIM(R,S,A).main()  @ &m: res] - 1%r
    = Pr[Game_SIM(R,S,A).game(true)  @ &m: res] 
      - Pr[Game_SIM(R,S,A).game(false)  @ &m: !res].
  proof.
    move=> Agen_ll Aget_ll Rgen_ll Ssimm_ll.
    rewrite Pr [mu_not].
    pose p1:= Pr[Game_SIM(R,S,A).game(true) @ &m: res].
    pose p2:= Pr[Game_SIM(R,S,A).game(false) @ &m: res].
    cut ->: Pr[Game_SIM(R,S,A).game(false) @ &m : true] = 1%r.
      byphoare (_: true) => //.
      by apply (Game_SIMgame_lossless R S A).
    cut Hp1: phoare [Game_SIM(R,S,A).game:
                     (glob Game_SIM(R,S,A)) = (glob Game_SIM(R,S,A)){m} /\ b ==> res] = p1.
      bypr=> &m' [eqG] b'; rewrite /p1 b'.
      by byequiv (_: ={glob Game_SIM(R,S,A), b} ==> ={res}); first by sim; sim.
    cut Hp2: phoare [Game_SIM(R,S,A).game:
                     (glob Game_SIM(R,S,A)) = (glob Game_SIM(R,S,A)){m} /\ !b ==> res] = p2.
      bypr=> &m' [eqG]; rewrite -neqF=> b'; rewrite /p2 b'.
      by byequiv (_: ={glob Game_SIM(R,S,A), b} ==> ={res}); first by sim; sim.
    cut Hp: phoare [Game_SIM(R,S,A).main:
                    (glob Game_SIM(R,S,A)) = (glob Game_SIM(R,S,A)){m} ==> res] = ((p1+p2)/2%r).
      proc => //.
      seq 1: real (1%r / 2%r) p1 (1%r / 2%r) p2 ((glob Game_SIM(R,S,A)) = (glob Game_SIM(R,S,A)){m}).
        by auto.
        by rnd ((=) true); skip; smt.
        by call Hp1.
        by rnd ((=) false); skip; smt.
        by call Hp2.
        by smt.
    cut ->: Pr[Game_SIM(R,S,A).main() @ &m : res] = ((p1+p2)/2%r).
      by byphoare Hp.
    by smt.
  qed.

end EncSecurity.
